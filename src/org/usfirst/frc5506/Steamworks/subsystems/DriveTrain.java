package org.usfirst.frc5506.Steamworks.subsystems;

import org.usfirst.frc5506.Steamworks.RobotMap;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;

public class DriveTrain extends Subsystem {
    private final SpeedController driveLeft = RobotMap.driveTrainDriveLeft;
    private final SpeedController driveRight = RobotMap.driveTrainDriveRight;
    public final AnalogGyro gyro = RobotMap.driveTrainGyro;

    private double lastLeftSpeed = 0d;
    private double lastRightSpeed = 0d;
    public boolean teleop = true;
    public final boolean accelCurve = true;

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveLeft(double speed) {
    	lastLeftSpeed = speed;
    	driveLeft.set(speed);
    }
    
    public void driveRight(double speed) {
    	lastRightSpeed = speed;
    	driveRight.set(-speed);
    }
    
    public void driveLeftCurved(double speed) {
    	if (!accelCurve) {
    		driveLeft(speed);
    		return;
    	}
    	if (speed > 0) {
    		if (speed > lastLeftSpeed + 0.04)
    			driveLeft(lastLeftSpeed + 0.04);
    		else
    			driveLeft(speed);
    	} else {
    		//if (speed < lastLeftSpeed - 0.04)
    		//	driveLeft(lastLeftSpeed - 0.04);
    		//else
    			driveLeft(speed);
    	}
    }
    
    public void driveRightCurved(double speed) {
    	if (!accelCurve) {
    		driveRight(speed);
    		return;
    	}
    	if (speed > 0) {
    		if (speed > lastRightSpeed + 0.04)
    			driveRight(lastRightSpeed + 0.04);
    		else
    			driveRight(speed);
    	} else {
    		//if (speed < lastRightSpeed - 0.04)
    		//	driveRight(lastRightSpeed - 0.04);
    		//else
    			driveRight(speed);
    	}
    }
    
    public void driveArcade(double forward, double turn) {
    	driveRight(forward + turn);
    	driveLeft(forward - turn);
    }
    
    public double getGyro() {
    	return gyro.getAngle();
    }
    
    /**
     * @return Angle between 0 (inclusive) and 360 (exclusive)
     */
    public double getGyroMod() {
    	return getGyro() % 360;
    }
}

