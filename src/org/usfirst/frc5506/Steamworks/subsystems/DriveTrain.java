package org.usfirst.frc5506.Steamworks.subsystems;

import org.usfirst.frc5506.Steamworks.RobotMap;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;

public class DriveTrain extends Subsystem {
    private final SpeedController driveLeft = RobotMap.driveTrainDriveLeft;
    private final SpeedController driveRight = RobotMap.driveTrainDriveRight;
    public final AnalogGyro gyro = RobotMap.driveTrainGyro;

    private double lastLeftSpeed = 0d;
    private double lastRightSpeed = 0d;
    public boolean teleop = true;
    public final boolean accelCurve = true;

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveLeft(double speed) {
    	lastLeftSpeed = speed;
    	driveLeft.set(speed);
        if (Math.abs(speed) >= 0.15)
            Robot.oi.getDriverJoystick().setRumble(RumbleType.kLeftRumble, Math.abs(speed));
        else
            Robot.oi.getDriverJoystick().setRumble(RumbleType.kLeftRumble, 0);
    }
    
    public void driveRight(double speed) {
    	lastRightSpeed = speed;
    	driveRight.set(-speed);
        if (Math.abs(speed) >= 0.15)
            Robot.oi.getDriverJoystick().setRumble(RumbleType.kRightRumble, Math.abs(speed));
        else
            Robot.oi.getDriverJoystick().setRumble(RumbleType.kRightRumble, 0);
    }
    
    public void driveLeftCurved(double speed) {
    	if (!accelCurve) {
    		driveLeft(speed);
    		return;
    	}
    	if (speed > 0) {
    		if (speed > lastLeftSpeed + 0.04)
    			driveLeft(lastLeftSpeed + 0.04);
    		else
    			driveLeft(speed);
    	} else {
    		//if (speed < lastLeftSpeed - 0.04)
    		//	driveLeft(lastLeftSpeed - 0.04);
    		//else
    			driveLeft(speed);
    	}
    }
    
    public void driveRightCurved(double speed) {
    	if (!accelCurve) {
    		driveRight(speed);
    		return;
    	}
    	if (speed > 0) {
    		if (speed > lastRightSpeed + 0.04)
    			driveRight(lastRightSpeed + 0.04);
    		else
    			driveRight(speed);
    	} else {
    		//if (speed < lastRightSpeed - 0.04)
    		//	driveRight(lastRightSpeed - 0.04);
    		//else
    			driveRight(speed);
    	}
    }
    
    public void driveArcade(double forward, double turn) {
    	driveRight(forward + turn);
    	driveLeft(forward - turn);
    }
    
    public double getGyro() {
    	return gyro.getAngle();
    }
    
    /**
     * @return Angle between 0 (inclusive) and 360 (exclusive)
     */
    public double getGyroMod() {
    	return getGyro() % 360;
    }
    
    /**
     * Calculates how far (and which way) to turn to match a target angle
     * @param target target (will be normalized between 0 and 360)
     * @return angle angle (between -180 and 180, inclusive)
     */
    public double getTurningAngle(double target) {
    	target = target % 360;
    	double current = getGyroMod();
    	if (Math.abs(target - current) <= 180) {
    		return target - current;
    	} else if (target < current) {
    		return target + 360 - current;
    	} else {
    		return target - 360 - current;
    	}
    }
}

