// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5506.Steamworks.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Subsystem;

import java.util.HashMap;

import org.usfirst.frc5506.Steamworks.Robot;

/**
 * syntax: command1;command2;/command3:0.3;command4:/1:5;command5;...lastCommand
 * 
 * Use ":" to split arguments, e.g. "command:2:3" runs "command" with 2 as arg1 and 3 as arg2
 * Use ";" to seperate commands, e.g. to run "command1" then "command2", use "command1;command2"
 * Use "/" before a command to run in parallel, e.g. to run "command1",
 * 		then run "command2" and "command3" at the same time (after "command1"), use "command1;/command2:command3"
 * 
 * 		Don't put "/" before your last command, there is no reason to.
 * 
 * Commands: (required param)	[optional param]
 * 
 * Drive(seconds)
 * 		Drives straight forward at full speed
 * TurnLeft(seconds)
 * 		Runs left motor back at full speed and right forwards at full speed
 * TurnRight(seconds)
 * 		Runs right motor back at full speed and left forwards at full speed
 * RunLeft(speed, time)
 * RunRight(speed, time)
 * CurveLeft(speed)
 * 		Accelerates left motor by 2%/tick until it reaches the required speed
 * 		At that rate, it nominally takes 1 second to accelerate to full speed
 * CurveRight(speed)
 * 		Accelerates right motor by 2%/tick until it reaches the required speed
 * 		At that rate, it nominally takes 1 second to accelerate to full speed
 * Gear
 * 		Lines up and puts the gear on the peg
 * FlattenConveyer
 * 		Moves conveyer forwards into flattened position for depositing balls
 * ResetConveyer
 * 		Moves conveyer to middle limit switch
 * PushGear
 * 		Moves conveyer towards gear end (as far as it will go)
 * 		Sorry, too lazy to come up with a better name
 * Wait(seconds)
 * 		Pauses
 */
public class RoutineCommand extends Command {
    private String command;
    private double arg;
    private double arg2;
    private boolean requiresDriveTrain = false;
    private boolean requiresConveyer = false;
    
    // used by some commands
    private boolean timeoutSet = false;
    private double accSpeed = 0d;
    
    // this allows a command to stop during execute() so I don't need two switch statements, shortens code significantly
    private boolean done = false;
    
    
    public RoutineCommand(String script) {
    	String[] split = script.split(":");
        command = split[0].toLowerCase();
        arg = split.length > 1 ? Double.valueOf(split[1]) : 0d;
        arg2 = split.length > 2 ? Double.valueOf(split[2]) : 0d;

        // IT IS IMPERITIVE THAT COMMANDS THAT MOVE SOMETHING ARE ADDED HERE
        // otherwise, motors WON'T STOP MOVING after the command ends
        if (command.equals("drive") || command.equals("turnleft") || command.equals("turnright") || command.equals("gear") ||
        	command.equals("runleft") || command.equals("runright") || command.equals("curveleft") || command.equals("curveright"))
        	requiresDriveTrain = true;
        if (command.equals("flattenconveyer") || command.equals("resetconveyer") || command.equals("pushgear"))
        	requiresConveyer = true;
        //if (requiresDriveTrain)
        //	requires(Robot.driveTrain);
        if (requiresConveyer)
        	requires(Robot.conveyer);
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	timeoutSet = false;
    	accSpeed = 0d;
    	if (requiresConveyer)
        	Robot.conveyer.teleop = false;
    	if (requiresDriveTrain)
    		Robot.driveTrain.teleop = false;
    	switch(command) {
    		case("drive"):
    			setTimeout(arg);
    			Robot.driveTrain.driveArcade(1, 0);
    			break;
    		case("turnleft"):
    			setTimeout(arg);
    			Robot.driveTrain.driveArcade(0, 0.5);
    			break;
    		case("turnright"):
    			setTimeout(arg);
    			Robot.driveTrain.driveArcade(0, -0.5);
    			break;
    		case("gear"):
    			// TODO
    			done = true;
    			break;
    		case("runleft"):
    			setTimeout(arg2);
    			Robot.driveTrain.driveLeft(arg);
    			break;
    		case("runright"):
    			setTimeout(arg2);
    			Robot.driveTrain.driveRight(arg);
    			break;
    		case("wait"):
    			setTimeout(arg);
    			break;
    		case("stop"):
    			Robot.driveTrain.driveArcade(0, 0);
    			done = true;
    			break;
    		default:
    			break;
    	}
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	switch(command) {
			case("curveleft"):
				if (arg > 0) {
					Robot.driveTrain.driveLeft(++accSpeed / 50);
					done = accSpeed / 50 >= arg;
				} else {
					Robot.driveTrain.driveLeft(--accSpeed / 50);
					done = accSpeed / 50 <= arg;
				}
				break;
			case("curveright"):
				if (arg > 0) {
					Robot.driveTrain.driveRight(++accSpeed / 50);
					done = accSpeed / 50 >= arg;
				} else {
					Robot.driveTrain.driveRight(--accSpeed / 50);
					done = accSpeed / 50 <= arg;
				}
				break;
    		case("gear"):
    			// TODO
    			break;
    		case("flattenconveyer"):
    			Robot.conveyer.set(-1);
    			if (Robot.conveyer.conveyorPos && !timeoutSet) {
    				timeoutSet = true;
    				setTimeout(1);
    			}
    			break;
    		case("resetconveyer"):
    			Robot.conveyer.set(Robot.conveyer.conveyorPos ? 1 : -1);
				done = Robot.conveyer.getSwitch();
				break;
    		case("pushgear"):
    			Robot.conveyer.set(1);
    			if (Robot.conveyer.conveyorPos && !timeoutSet) {
    				timeoutSet = true;
    				setTimeout(3);
    			}
    			break;
			default:
				break;
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return done || isTimedOut();
    }

    // Called once after isFinished returns true
    protected void end() {
    	//if (requiresDriveTrain)
    	//	Robot.driveTrain.driveArcade(0, 0); // why use two lines of code when you can have one?
    	// notice the lack of "else" here
    	// this allows a command to safely require both the DriveTrain and the Conveyer
    	if (requiresDriveTrain)
    		Robot.driveTrain.teleop = true;
    	if (requiresConveyer) {
    		Robot.conveyer.set(0);
    		Robot.conveyer.teleop = true;
    	}
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	//if (requiresDriveTrain)
    	//	Robot.driveTrain.driveArcade(0, 0); // why use two lines of code when you can have one?
    	// notice the lack of "else" here
    	// this allows a command to safely require both the DriveTrain and the Conveyer
    	if (requiresDriveTrain)
    		Robot.driveTrain.teleop = true;
    	if (requiresConveyer) {
    		Robot.conveyer.set(0);
    		Robot.conveyer.teleop = true;
    	}
    }
}
